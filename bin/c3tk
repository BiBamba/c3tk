#!/usr/bin/env bash

install_cmds() {
  for _cmd in "${@}"
  do
    [[ -x ${INSTALL_PATH}/${_cmd} ]] ||
      ln -fs ${INSTALL_PATH}/c3tk ${INSTALL_PATH}/${_cmd}
  done
}

install() {
  mkdir -p "${INSTALL_PATH}" "${CONFIG_PATH}"/{cmds,config}
  cp $0 "${INSTALL_PATH}/c3tk"
  if (( $# == 0 ))
  then
    _cmds=($(find "${CONFIG_PATH}/cmds" -mindepth 1 -maxdepth 1 -type f | sed -e "s#${CONFIG_PATH}\/cmds##"))
    install_cmds ${_cmds[@]}
  fi
  echo -e "Be sure to add ${INSTALL_PATH} to your path:\n\texport PATH=\"${INSTALL_PATH}:\$PATH\""
  echo "install_path=${INSTALL_PATH}" > ${CONFIG_PATH}/install
  exit 0
}

docker_run() {
  exec docker run --rm --platform="linux/amd64" -w '/w' -v ${PWD}:/w "${@}"
}

add_help() {
  echo <<-HELP
c3tk add <name> image=<img> [tag=<tag>] [configs=.<a>,.<b>,...] [tty] [stream]

Where:
   name    - command name to expose to the host system
   tag     - image tag to use, defaults to :latest
   image   - docker compatible registry url
   configs - comma separated list of config files to map via -v
   tty     - if present will add '-t' 
   stream  - if present will add '--log-driver=none -a stdin -a stdout -a stderr'

HELP
}

add_cmd() {
  (( $# > 1 )) || fail "$(add_usage)"

  local _cmd _image _tag
  _cmd="$1" && shift || fail "$(add_usage)"
  # TODO: If empty check if definition file already exists, if so symlink.
  if (( $# > 0 ))
  then
    for arg in "${@}" 
    do 
      case "${arg}" in
        (image=*)
          _image=$(echo ${arg} | awk -F= '{print $2}')
          ;;
        (tag=*)
          _tag=$(echo ${arg} | awk -F= '{print $2}')
          [[ -n "${_tag}" ]] || _tag="latest"
          ;;
      esac
      echo "${arg}" >> ${CONFIG_PATH}/${_cmd}
    done
    [[ -n "${_image}" ]] || fail "Image Required"
  else
    if [[ -s ${CONFIG_PATH}/${_cmd} ]]
    then
      _image=$(awk -F= '/image=/{print $2}' ${CONFIG_PATH}/${cmd})
      _tag=$(awk -F= '/tag=/{print $2}' ${CONFIG_PATH}/${cmd})
    fi
    [[ -n "${_image}" ]] || fail "$(add_usage)"
  fi
  ln -fs ${INSTALL_PATH}/c3tk ${INSTALL_PATH}/${_cmd}
  docker pull ${_image}:${_tag:-latest}
}

configure() {
  local _config _group
  for _config in $(find ~/.config/c3tk/config  -iname '*.c3tk')
  do
    _group=$(basename ${_config} '.c3tk')
    while read _line 
    do 
      echo " ${_group} => ${_line}"
      $0 $_line
    done < <(cat ${_config} | sed -e '/^[[:blank:]]*#/d;s/#.*//')
  done
}

fetch_add() {
  # 1. Curl URL to .c3tk file
  # 2. Configure 
  true
}

shell_for() {
  [[ -s "${CONFIG_PATH}/$1" ]] || fail "$1 not added."
  image=$(awk -F= '/image=/{print $2}' ${CONFIG_PATH}/$1)
  docker_run -it -v $HOME/:/root "${image}" bash "${@}"
}


# Allow this script to be symlinked as the actual command name :)
cmd="$1" ; [[ ${0//*\/} == "c3tk" ]]  && shift || cmd="${0//*\/}"

true \
  "${CONFIG_PATH:="$HOME/.config/c3tk"}" \
  "${INSTALL_PREFIX:="/usr/local/bin"}" \
  "${INSTALL_PATH:="${INSTALL_PREFIX}/c3tk/bin"}" \
  "${IMAGE_TAG:="${TAG:-latest}"}"

[[ "" == "${DEBUG}" ]] || set -xv

touch ~/.saferc ~/.vaultrc ~/.flyrc

[[ install != "${cmd}" ]] || install

case "${cmd}" in 
  (configure) configure "${@}" ;;
  (fetch) fetch_add "${@}" ;;
  (add) add_cmd "$@" ;;
  (shell) shell_for ${cmd} ;;
  (*)
    if [[ -s "${CONFIG_PATH}/${cmd}" ]]
    then
      _image=$(awk -F= '/image/{print $2}' "${CONFIG_PATH}/${cmd}")
      _tag=$(awk -F= '/tag/{print $2}' "${CONFIG_PATH}/${cmd}")
      _configs=($(awk -F= '/configs/{print $2}' "${CONFIG_PATH}/${cmd}" | tr ',' ' '))
      _cmd=($(awk -F= '/cmd/{print $2}' "${CONFIG_PATH}/${cmd}" ))
      grep -q 'stream' "${CONFIG_PATH}/${cmd}" &&
        _c="${_c} --log-driver=none -a stdin -a stdout -a stderr "
      grep -q 'tty' "${CONFIG_PATH}/${cmd}" && 
        _c="${_c} -t "

      for _config in "${_configs[@]}"
      do _c="${_c} -v $HOME/${_config}:/root/${_config}"
      done

      docker_run -i ${_c} "${_image}:${_tag:-latest}" "${_cmd:-"${cmd}"}" "${@}"
    else
      fail "${cmd} not found, do you need to \`add\` it?"
    fi

    ;;
esac

exit 0
